type AllowanceError = variant {
  AllowanceNotFound;
  BadSpender;
  AllowanceChanged;
  BadExpiration;
  AllowanceExpired;
  InsufficientFunds;
};
type BalanceError = variant { AccountNotFound; InsufficientBalance };
type ConfigurationError = variant { AdminsCantBeEmpty; AnonymousAdmin };
type ConfigurationError_1 = variant {
  CustodialsCantBeEmpty;
  AnonymousCustodial;
};
type Contract = record {
  id : nat;
  value : nat64;
  "type" : ContractType;
  is_signed : bool;
  properties : vec record { text; GenericValue };
  sellers : vec Seller;
  tokens : vec nat;
  currency : text;
  installments : nat64;
  initial_value : nat64;
  buyers : vec principal;
};
type ContractRegistration = record {
  value : nat64;
  "type" : ContractType;
  properties : vec record { text; GenericValue };
  sellers : vec Seller;
  currency : text;
  installments : nat64;
  buyers : vec principal;
};
type ContractType = variant { Sell; Financing };
type DeferredError = variant {
  Nft : NftError;
  Ekoke : EkokeError;
  Configuration : ConfigurationError_1;
  Unauthorized;
  Token : TokenError;
  StorageError;
  CanisterCall : record { RejectionCode; text };
};
type DeferredInitData = record {
  ekoke_canister : principal;
  custodians : vec principal;
  marketplace_canister : principal;
};
type EcdsaError = variant {
  RecoveryIdError;
  InvalidSignature;
  InvalidPublicKey;
};
type EkokeError = variant {
  Configuration : ConfigurationError;
  Icrc1Transfer : TransferError;
  Pool : PoolError;
  Allowance : AllowanceError;
  Register : RegisterError;
  EthRpcError : record { int32; text };
  XrcError;
  StorageError;
  CanisterCall : record { RejectionCode; text };
  Balance : BalanceError;
  Icrc2Transfer : TransferFromError;
  Ecdsa : EcdsaError;
};
type GenericValue = variant {
  Nat64Content : nat64;
  Nat32Content : nat32;
  BoolContent : bool;
  Nat8Content : nat8;
  Int64Content : int64;
  IntContent : int;
  NatContent : nat;
  Nat16Content : nat16;
  Int32Content : int32;
  Int8Content : int8;
  FloatContent : float64;
  Int16Content : int16;
  BlobContent : vec nat8;
  NestedContent : Vec;
  Principal : principal;
  TextContent : text;
};
type Metadata = record {
  logo : opt text;
  name : opt text;
  created_at : nat64;
  upgraded_at : nat64;
  custodians : vec principal;
  symbol : opt text;
};
type NftError = variant {
  UnauthorizedOperator;
  SelfTransfer;
  TokenNotFound;
  UnauthorizedOwner;
  TxNotFound;
  SelfApprove;
  OperatorNotFound;
  ExistedNFT;
  OwnerNotFound;
  Other : text;
};
type PoolError = variant { PoolNotFound : nat; NotEnoughTokens };
type RegisterError = variant { TransactionNotFound };
type RejectionCode = variant {
  NoError;
  CanisterError;
  SysTransient;
  DestinationInvalid;
  Unknown;
  SysFatal;
  CanisterReject;
};
type Result = variant { Ok; Err : DeferredError };
type Result_1 = variant { Ok : nat; Err : NftError };
type Result_2 = variant { Ok : bool; Err : NftError };
type Result_3 = variant { Ok : opt principal; Err : NftError };
type Result_4 = variant { Ok : vec nat; Err : NftError };
type Result_5 = variant { Ok : vec TokenMetadata; Err : NftError };
type Result_6 = variant { Ok : nat; Err : DeferredError };
type Result_7 = variant { Ok : TokenMetadata; Err : NftError };
type Result_8 = variant { Ok : TxEvent; Err : NftError };
type Role = variant { Custodian; Agent };
type Seller = record { "principal" : principal; quota : nat8 };
type Stats = record {
  cycles : nat;
  total_transactions : nat;
  total_unique_holders : nat;
  total_supply : nat;
};
type SupportedInterface = variant { Burn; Mint; Approval; TransactionHistory };
type Token = record {
  id : nat;
  transferred_at : opt nat64;
  transferred_by : opt principal;
  picoekoke_reward : nat;
  value : nat64;
  owner : opt principal;
  operator : opt principal;
  approved_at : opt nat64;
  approved_by : opt principal;
  contract_id : nat;
  is_burned : bool;
  burned_at : opt nat64;
  burned_by : opt principal;
  minted_at : nat64;
  minted_by : principal;
};
type TokenError = variant {
  ContractAlreadySigned : nat;
  ContractValueIsNotMultipleOfInstallments;
  TokenAlreadyExists : nat;
  TokensMismatch;
  ContractAlreadyExists : nat;
  ContractTokensShouldBeEmpty;
  TokenDoesNotBelongToContract : nat;
  TokenNotFound : nat;
  ContractSellerQuotaIsNot100;
  ContractNotFound : nat;
  CannotCloseContract;
  ContractNotSigned : nat;
  ContractHasNoSeller;
  ContractHasNoTokens;
  TokenIsBurned : nat;
  BadMintTokenOwner : nat;
  BadContractProperty;
};
type TokenInfo = record { token : Token; contract : Contract };
type TokenMetadata = record {
  transferred_at : opt nat64;
  transferred_by : opt principal;
  owner : opt principal;
  operator : opt principal;
  approved_at : opt nat64;
  approved_by : opt principal;
  properties : vec record { text; GenericValue };
  is_burned : bool;
  token_identifier : nat;
  burned_at : opt nat64;
  burned_by : opt principal;
  minted_at : nat64;
  minted_by : principal;
};
type TransferError = variant {
  GenericError : record { message : text; error_code : nat };
  TemporarilyUnavailable;
  BadBurn : record { min_burn_amount : nat };
  Duplicate : record { duplicate_of : nat };
  BadFee : record { expected_fee : nat };
  CreatedInFuture : record { ledger_time : nat64 };
  TooOld;
  InsufficientFunds : record { balance : nat };
};
type TransferFromError = variant {
  GenericError : record { message : text; error_code : nat };
  TemporarilyUnavailable;
  InsufficientAllowance : record { allowance : nat };
  BadBurn : record { min_burn_amount : nat };
  Duplicate : record { duplicate_of : nat };
  BadFee : record { expected_fee : nat };
  CreatedInFuture : record { ledger_time : nat64 };
  TooOld;
  InsufficientFunds : record { balance : nat };
};
type TxEvent = record {
  time : nat64;
  operation : text;
  details : vec record { text; GenericValue };
  caller : principal;
};
type Vec = vec record {
  text;
  variant {
    Nat64Content : nat64;
    Nat32Content : nat32;
    BoolContent : bool;
    Nat8Content : nat8;
    Int64Content : int64;
    IntContent : int;
    NatContent : nat;
    Nat16Content : nat16;
    Int32Content : int32;
    Int8Content : int8;
    FloatContent : float64;
    Int16Content : int16;
    BlobContent : vec nat8;
    NestedContent : Vec;
    Principal : principal;
    TextContent : text;
  };
};
service : (DeferredInitData) -> {
  admin_get_unsigned_contracts : () -> (vec nat) query;
  admin_remove_role : (principal, Role) -> (Result);
  admin_set_ekoke_canister : (principal) -> ();
  admin_set_marketplace_canister : (principal) -> ();
  admin_set_role : (principal, Role) -> ();
  admin_sign_contract : (nat) -> (Result);
  approve : (principal, nat) -> (Result_1);
  balance_of : (principal) -> (Result_1) query;
  burn : (nat) -> (Result_1);
  custodians : () -> (vec principal) query;
  cycles : () -> (nat) query;
  get_contract : (nat) -> (opt Contract) query;
  get_signed_contracts : () -> (vec nat) query;
  get_token : (nat) -> (opt TokenInfo) query;
  is_approved_for_all : (principal, principal) -> (Result_2);
  logo : () -> (opt text) query;
  metadata : () -> (Metadata) query;
  mint : (principal, nat, vec record { text; GenericValue }) -> (Result_1);
  name : () -> (opt text) query;
  operator_of : (nat) -> (Result_3) query;
  operator_token_identifiers : (principal) -> (Result_4) query;
  operator_token_metadata : (principal) -> (Result_5) query;
  owner_of : (nat) -> (Result_3) query;
  owner_token_identifiers : (principal) -> (Result_4) query;
  owner_token_metadata : (principal) -> (Result_5) query;
  register_contract : (ContractRegistration) -> (Result_6);
  seller_increment_contract_value : (nat, nat64, nat64) -> (Result);
  set_approval_for_all : (principal, bool) -> (Result_1);
  set_custodians : (vec principal) -> ();
  set_logo : (text) -> ();
  set_name : (text) -> ();
  set_symbol : (text) -> ();
  stats : () -> (Stats) query;
  supported_interfaces : () -> (vec SupportedInterface) query;
  symbol : () -> (opt text) query;
  token_metadata : (nat) -> (Result_7) query;
  total_supply : () -> (nat) query;
  total_transactions : () -> (nat) query;
  total_unique_holders : () -> (nat) query;
  transaction : (nat) -> (Result_8) query;
  transfer : (principal, nat) -> (Result_1);
  transfer_from : (principal, principal, nat) -> (Result_1);
  update_contract_buyers : (nat, vec principal) -> (Result);
  update_contract_property : (nat, text, GenericValue) -> (Result);
}