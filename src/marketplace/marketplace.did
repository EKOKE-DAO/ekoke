type AllowanceError = variant {
  AllowanceNotFound;
  BadSpender;
  AllowanceChanged;
  BadExpiration;
  AllowanceExpired;
  InsufficientFunds;
};
type BalanceError = variant { AccountNotFound; InsufficientBalance };
type BuyError = variant {
  TokenHasNoOwner;
  IcpAllowanceNotEnough;
  CallerAlreadyOwnsToken;
  IcpAllowanceExpired;
};
type ConfigurationError = variant { AdminsCantBeEmpty; AnonymousAdmin };
type ConfigurationError_1 = variant {
  CustodialsCantBeEmpty;
  AnonymousCustodial;
};
type DeferredError = variant {
  Fly : FlyError;
  Nft : NftError;
  Configuration : ConfigurationError_1;
  Unauthorized;
  Token : TokenError;
  StorageError;
  CanisterCall : record { RejectionCode; text };
};
type FlyError = variant {
  Configuration : ConfigurationError;
  Icrc1Transfer : TransferError;
  Pool : PoolError;
  Allowance : AllowanceError;
  Register : RegisterError;
  XrcError;
  StorageError;
  CanisterCall : record { RejectionCode; text };
  Balance : BalanceError;
  Icrc2Transfer : TransferFromError;
};
type MarketplaceError = variant {
  Buy : BuyError;
  Configuration : ConfigurationError;
  Icrc1Transfer : TransferError;
  DeferredCanister : DeferredError;
  TokenNotFound;
  FlyCanister : FlyError;
  XrcError;
  StorageError;
  CanisterCall : record { RejectionCode; text };
  Dip721 : NftError;
  Icrc2Transfer : TransferFromError;
};
type MarketplaceInitData = record {
  deferred_canister : principal;
  fly_canister : principal;
  admins : vec principal;
};
type NftError = variant {
  UnauthorizedOperator;
  SelfTransfer;
  TokenNotFound;
  UnauthorizedOwner;
  TxNotFound;
  SelfApprove;
  OperatorNotFound;
  ExistedNFT;
  OwnerNotFound;
  Other : text;
};
type PoolError = variant { PoolNotFound : nat; NotEnoughTokens };
type RegisterError = variant { TransactionNotFound };
type RejectionCode = variant {
  NoError;
  CanisterError;
  SysTransient;
  DestinationInvalid;
  Unknown;
  SysFatal;
  CanisterReject;
};
type Result = variant { Ok; Err : MarketplaceError };
type Result_1 = variant { Ok : nat64; Err : MarketplaceError };
type TokenError = variant {
  ContractAlreadySigned : nat;
  ContractValueIsNotMultipleOfInstallments;
  TokenAlreadyExists : nat;
  TokensMismatch;
  ContractAlreadyExists : nat;
  ContractTokensShouldBeEmpty;
  TokenDoesNotBelongToContract : nat;
  TokenNotFound : nat;
  ContractSellerQuotaIsNot100;
  ContractNotFound : nat;
  CannotCloseContract;
  ContractNotSigned : nat;
  ContractHasNoSeller;
  ContractHasNoTokens;
  TokenIsBurned : nat;
  BadMintTokenOwner : nat;
  BadContractProperty;
};
type TransferError = variant {
  GenericError : record { message : text; error_code : nat };
  TemporarilyUnavailable;
  BadBurn : record { min_burn_amount : nat };
  Duplicate : record { duplicate_of : nat };
  BadFee : record { expected_fee : nat };
  CreatedInFuture : record { ledger_time : nat64 };
  TooOld;
  InsufficientFunds : record { balance : nat };
};
type TransferFromError = variant {
  GenericError : record { message : text; error_code : nat };
  TemporarilyUnavailable;
  InsufficientAllowance : record { allowance : nat };
  BadBurn : record { min_burn_amount : nat };
  Duplicate : record { duplicate_of : nat };
  BadFee : record { expected_fee : nat };
  CreatedInFuture : record { ledger_time : nat64 };
  TooOld;
  InsufficientFunds : record { balance : nat };
};
service : (MarketplaceInitData) -> {
  admin_cycles : () -> (nat) query;
  admin_set_admins : (vec principal) -> (Result);
  admin_set_deferred_canister : (principal) -> ();
  admin_set_fly_canister : (principal) -> (Result);
  admin_set_interest_rate_for_buyer : (float64) -> ();
  buy_token : (nat, opt vec nat8) -> (Result);
  get_token_price_icp : (nat) -> (Result_1);
}